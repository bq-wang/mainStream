// propertiesSynthesizedAccessorsInstanceVariables_main.m

/* So any references you see in the template code generated by Xcode to variables starting with a _ are referencing the instance variables directly by name.

 When you see an @synthesize directive that looks like this@synthesize window=_window;

This helps to distinguish the vlaue of the instance variable through the setter and getter methods. That is, writing something like this: 

[window makeKeyAndVisible]; // This won't work

will fail, as there is no  instance variable named window, Instead , you have to either name the instance variable directly by its name, such as 

[_window makeKeyAndVisible];

or, preferably, use the accessor method:

[self.window makeKeyAndVisible];
 
As you know, instance variables declared either explicitly in the implementation section (or implicitly by using the @synthesize directive) are made private, meaning they¡¯re not accessible to subclasses directly by name.
*/


/*

global variables:

If you write the statement:

int gMoveNumber = 0;


at the beginning of your program¡ªoutside any method, class definition, or function¡ªits value can be referenced from anywhere in that module. In such a case, we say that 'gMoveNumber' is defined as a global variable.

this same definition of the variable gMoveNumber also makes its value accessible from other files. Specifically, the preceding statement defines the variable gMoveNumber not just as a global variable, but as an external global variable.

An external variable is one whose value can be accessed and changed by any other methods or functions. Inside the module hat wants to access the external variable, the variable is declared in the normal fashion and the keyword 'extern' is placed before the 
the declaration. 

'extern int gMoveNumber; '

this is C

the seocnd way to define an external variable is to declare the variable any function, placing the keyword 'extern' in front of the declaration and explicitly assigning an initial value to it, like this:

'extern int gMoveNumber = 0;'

However, this is not the preferred way to do this, and the compiler warns you that you¡¯ve declared the variable 'extern' and assigned it a value at the same time.That¡¯s because using the word extern makes it a declaration for the variable, not a definition. The previous example violates this rule by forcing a declaration to be treated as a definition (by assigning it an initial value). 

*/